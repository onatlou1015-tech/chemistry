<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=no">
    <title>Periodic table ¬∑ drag & match</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Arial', sans-serif;
            user-select: none;
        }

        body {
            background: linear-gradient(145deg, #0f2e3a, #1a4740);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 12px;
            touch-action: pan-y;
        }

        /* MAIN CONTAINER ‚Äî RESPECTS SCREEN SIZE */
        .game-container {
            width: 100%;
            max-width: 1400px;
            background: #204e4a;
            background: radial-gradient(circle at 20% 30%, #31736e, #154542);
            border-radius: 60px 60px 40px 40px;
            box-shadow: 0 20px 35px #071e1e;
            padding: 20px;
            border-bottom: 12px solid #0d3d3a;
            display: flex;
            flex-direction: column;
            height: 98vh;
            max-height: 1000px;
        }

        /* HEADER ‚Äì TEAM SCORE & ROUND */
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #062d2b;
            padding: 12px 30px;
            border-radius: 70px;
            color: #fdffc4;
            border-bottom: 8px solid #6f9e5f;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .title {
            font-size: 2rem;
            letter-spacing: 6px;
            font-weight: 700;
            text-shadow: 0 4px 0 #124d3a;
        }

        .team-score {
            background: #1a352c;
            padding: 8px 30px;
            border-radius: 50px;
            font-size: 1.9rem;
            font-weight: bold;
            color: #fff8b5;
            box-shadow: inset 0 0 0 4px #edd46b;
            display: flex;
            gap: 30px;
        }

        .score-badge {
            display: flex;
            gap: 10px;
        }

        /* MAIN PLAY AREA: GRID (LEFT) + ELEMENT DECK (RIGHT) */
        .play-area {
            display: flex;
            flex: 1;
            min-height: 0;
            gap: 20px;
            flex-wrap: wrap;
        }

        /* ---------- PERIODIC TABLE GRID (CSS GRID) ---------- */
        .table-section {
            flex: 3 1 700px;
            background: #17423d;
            border-radius: 50px;
            padding: 18px;
            box-shadow: inset 0 -8px 0 #0c2f2c, inset 0 0 20px #6cc9c0;
            border: 6px solid #ffe68f;
            display: flex;
            flex-direction: column;
        }

        .grid-title {
            color: #fffece;
            font-size: 1.8rem;
            margin-bottom: 12px;
            text-align: center;
            background: #1a534b;
            padding: 6px;
            border-radius: 50px;
            border-bottom: 6px solid #b6ad60;
        }

        .periodic-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);  /* 6 columns for simplicity */
            gap: 12px;
            flex: 1;
            background: #0e403f;
            padding: 16px;
            border-radius: 40px;
            box-shadow: inset 0 0 0 4px #7dad73;
        }

        /* each cell in periodic table */
        .grid-cell {
            background: #213d3a;
            border-radius: 20px;
            box-shadow: inset 0 -6px 0 #0e2624, inset 0 2px 10px #a5e0d0;
            border: 3px solid #fbeaa0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            aspect-ratio: 1 / 1;
            min-height: 70px;
            font-size: 1.8rem;
            font-weight: bold;
            color: #fffcd1;
            position: relative;
            transition: 0.1s;
            padding: 4px;
        }

        /* occupied cell ‚Äî shows element */
        .cell-occupied {
            background: radial-gradient(circle at 30% 30%, #fff4b5, #f7cf7c);
            color: #072a3d;
            border: 5px solid #ffe180;
            box-shadow: 0 0 0 3px #ffd966, inset 0 -4px 0 #b89b40;
        }

        .cell-occupied .element-symbol {
            font-size: 2.2rem;
            font-weight: 800;
        }

        .cell-occupied .element-name {
            font-size: 0.9rem;
            background: #386035;
            color: white;
            padding: 3px 8px;
            border-radius: 30px;
            margin-top: 4px;
        }

        /* ---------- ELEMENT DECK (right side) ---------- */
        .element-deck {
            flex: 1 1 260px;
            background: #1f534a;
            border-radius: 60px 60px 30px 30px;
            padding: 20px 16px;
            box-shadow: inset 0 -8px 0 #0e3532, inset 0 6px 20px #baffd0;
            border: 6px solid #ffe694;
            display: flex;
            flex-direction: column;
        }

        .deck-header {
            color: #fffdbb;
            font-size: 1.9rem;
            text-align: center;
            border-bottom: 6px solid #fbff8e;
            padding-bottom: 10px;
            margin-bottom: 18px;
            text-shadow: 0 3px 0 #27633a;
        }

        /* element cards container ‚Äî scrollable */
        .cards-container {
            display: flex;
            flex-direction: column;
            gap: 18px;
            flex: 1;
            overflow-y: auto;
            padding-right: 6px;
        }

        /* draggable element card ‚Äî LARGE, COLOR-CODED */
        .element-card {
            background: radial-gradient(circle at 20% 40%, #ffe6a3, #facf7c);
            padding: 22px 12px;
            border-radius: 70px;
            border-bottom: 12px solid #a4662e;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 2.4rem;
            font-weight: bold;
            color: #102c3a;
            box-shadow: 0 12px 0 #6b421f, 0 15px 25px black;
            transition: 0.05s;
            cursor: grab;
            touch-action: none;
            border: 4px solid #ffeeb5;
            position: relative;
            z-index: 9999;
            pointer-events: auto;
        }

        .element-card:active {
            cursor: grabbing;
            transform: scale(1.02);
            box-shadow: 0 8px 0 #6b421f, 0 18px 30px black;
        }

        .element-card span {
            background: #1a4b3c;
            color: white;
            padding: 8px 22px;
            border-radius: 60px;
            font-size: 1.6rem;
            border-bottom: 6px solid #0b2e25;
        }

        /* color coding by group ‚Äî nonmetal, alkali, etc. */
        .card-nonmetal { background: radial-gradient(#b3e0b0, #5f9e6b); border-bottom-color: #1f5420; }
        .card-alkali { background: radial-gradient(#ffb5b5, #c75959); border-bottom-color: #712a2a; }
        .card-alkaline { background: radial-gradient(#ffe0a3, #d89e4a); border-bottom-color: #7e5829; }
        .card-halogen { background: radial-gradient(#c7b5ff, #816ac7); border-bottom-color: #45397a; }
        .card-noble { background: radial-gradient(#a4e3e0, #479b9b); border-bottom-color: #1f5c5c; }

        .reset-area {
            margin-top: 16px;
            display: flex;
            justify-content: center;
            gap: 30px;
        }

        .btn {
            background: #dba443;
            border: none;
            border-bottom: 10px solid #7e5926;
            font-size: 1.8rem;
            font-weight: bold;
            padding: 14px 40px;
            border-radius: 80px;
            color: #0c382b;
            letter-spacing: 6px;
            box-shadow: 0 10px 0 #5d3f1f;
            transition: 0.05s;
            cursor: pointer;
        }

        .btn:active {
            transform: translateY(10px);
            box-shadow: 0 2px 0 #5d3f1f;
            border-bottom-width: 4px;
        }

        .win-message {
            background: #12312b;
            padding: 14px 30px;
            border-radius: 60px;
            color: #ffef9e;
            font-size: 1.7rem;
            border: 4px solid #ffcf6e;
            text-align: center;
        }

        /* hover highlight for groups ‚Äî interactive board adaptation */
        .grid-cell[data-group="1"]:hover { background: #e6a2a2; border-color: #ffd966; }
        .grid-cell[data-group="2"]:hover { background: #f0cf9c; border-color: #ffd966; }
        .grid-cell[data-group="17"]:hover { background: #b6a2e6; border-color: #ffd966; }
        .grid-cell[data-group="18"]:hover { background: #9fdfdf; border-color: #ffd966; }
        .grid-cell[data-group="nonmetal"]:hover { background: #a1cf9b; border-color: #ffd966; }
    </style>
</head>
<body>
    <!-- SCREEN SIZE DETECTION - dynamic resize -->
    <div class="game-container" id="gameContainer">
        <div class="game-header">
            <div class="title">‚öõÔ∏è PERIODIC MATCH</div>
            <div class="team-score">
                <span class="score-badge">üèÜ LEFT <span id="leftScore">0</span></span>
                <span class="score-badge">üèÜ RIGHT <span id="rightScore">0</span></span>
            </div>
        </div>

        <!-- main play area: periodic grid + draggable deck -->
        <div class="play-area">
            <!-- PERIODIC TABLE GRID (6 columns, simplified) -->
            <div class="table-section">
                <div class="grid-title">üî¨ drop here ‚Üí</div>
                <div id="periodicGrid" class="periodic-grid">
                    <!-- JS will inject cells -->
                </div>
            </div>

            <!-- ELEMENT DECK: floating element cards -->
            <div class="element-deck">
                <div class="deck-header">üß™ ELEMENT CARDS</div>
                <div id="cardsContainer" class="cards-container">
                    <!-- dynamic draggable cards -->
                </div>
            </div>
        </div>

        <!-- difficulty & reset + win message -->
        <div class="reset-area">
            <button id="resetBtn" class="btn">‚Üª NEW ROUND</button>
            <button id="nextRoundBtn" class="btn">‚ûï ADD ELEMENTS</button>
        </div>
        <div id="winMessage" class="win-message" style="margin-top: 16px;">
            ‚ö° Drag elements to correct cells. Left/Right team scores!
        </div>
    </div>

    <script>
        (function() {
            "use strict";

            // ---------- PERIODIC ELEMENT DATA (simplified, color-coded) ----------
            const ELEMENT_DATA = [
                { symbol: "H", name: "Hydrogen", row: 1, col: 1, group: "nonmetal" },
                { symbol: "He", name: "Helium", row: 1, col: 6, group: "noble" },
                { symbol: "Li", name: "Lithium", row: 2, col: 1, group: "alkali" },
                { symbol: "Be", name: "Beryllium", row: 2, col: 2, group: "alkaline" },
                { symbol: "B", name: "Boron", row: 2, col: 3, group: "nonmetal" },
                { symbol: "C", name: "Carbon", row: 2, col: 4, group: "nonmetal" },
                { symbol: "N", name: "Nitrogen", row: 2, col: 5, group: "nonmetal" },
                { symbol: "O", name: "Oxygen", row: 2, col: 6, group: "nonmetal" },
                { symbol: "F", name: "Fluorine", row: 2, col: 7, group: "halogen" },
                { symbol: "Ne", name: "Neon", row: 2, col: 8, group: "noble" },
                { symbol: "Na", name: "Sodium", row: 3, col: 1, group: "alkali" },
                { symbol: "Mg", name: "Magnesium", row: 3, col: 2, group: "alkaline" },
                { symbol: "Al", name: "Aluminum", row: 3, col: 3, group: "nonmetal" },
                { symbol: "Si", name: "Silicon", row: 3, col: 4, group: "nonmetal" },
                { symbol: "P", name: "Phosphorus", row: 3, col: 5, group: "nonmetal" },
                { symbol: "S", name: "Sulfur", row: 3, col: 6, group: "nonmetal" },
                { symbol: "Cl", name: "Chlorine", row: 3, col: 7, group: "halogen" },
                { symbol: "Ar", name: "Argon", row: 3, col: 8, group: "noble" }
            ];

            // Difficulty progression: rounds 1,2,3 add more elements
            const ROUND_LEVELS = [6, 10, 14, 18]; // how many elements appear

            // GAME STATE
            let currentRound = 0;          // 0-indexed
            let activeElements = [];       // subset of ELEMENT_DATA
            let placedElements = [];       // ids of correctly placed elements
            let leftTeamScore = 0;
            let rightTeamScore = 0;
            let currentTeam = 'left';      // alternate turns (relay race)
            let elementCounter = 0;

            // Drag state
            let draggingCard = null;
            let dragElementId = null;
            let dragStartX = 0, dragStartY = 0;
            let initialLeft = 0, initialTop = 0;

            // DOM elements
            const gridContainer = document.getElementById('periodicGrid');
            const cardsContainer = document.getElementById('cardsContainer');
            const leftScoreEl = document.getElementById('leftScore');
            const rightScoreEl = document.getElementById('rightScore');
            const winMsg = document.getElementById('winMessage');
            const resetBtn = document.getElementById('resetBtn');
            const nextBtn = document.getElementById('nextRoundBtn');

            // ---------- SCREEN SIZE DETECTION: ensure grid fits ----------
            function adjustGridToScreen() {
                const container = document.querySelector('.game-container');
                const vw = window.innerWidth;
                const vh = window.innerHeight;
                // nothing critical, but we ensure grid columns are stable
                let grid = document.querySelector('.periodic-grid');
                if (grid) {
                    if (vw < 900) {
                        grid.style.gap = '8px';
                    } else {
                        grid.style.gap = '12px';
                    }
                }
            }
            window.addEventListener('resize', adjustGridToScreen);

            // ---------- CREATE PERIODIC GRID CELLS (6x8 simplified) ----------
            function buildGrid() {
                gridContainer.innerHTML = '';
                // we create 6 columns, 4 rows (but we support up to row 3, col 8)
                for (let row = 1; row <= 4; row++) {
                    for (let col = 1; col <= 8; col++) {
                        if (row === 1 && col > 6) continue; // He at col6, skip extra
                        if (row === 1 && col === 2) continue; // no element
                        if (row === 1 && col === 3) continue;
                        if (row === 1 && col === 4) continue;
                        if (row === 1 && col === 5) continue;
                        if (row === 4 && col > 4) continue; // keep simple
                        
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        cell.dataset.occupied = 'false';
                        cell.dataset.elementId = '';
                        
                        // group attribute for hover highlighting
                        let group = '';
                        const el = ELEMENT_DATA.find(e => e.row === row && e.col === col);
                        if (el) group = el.group;
                        cell.dataset.group = group || '';
                        
                        // if there is a default element, we will fill later when placed
                        gridContainer.appendChild(cell);
                    }
                }
            }

            // ---------- START ROUND: load active elements ----------
            function loadRound(roundIndex) {
                const count = ROUND_LEVELS[Math.min(roundIndex, ROUND_LEVELS.length - 1)];
                // pick first 'count' elements from ELEMENT_DATA
                activeElements = ELEMENT_DATA.slice(0, count).map(el => ({
                    ...el,
                    id: elementCounter++,
                    isPlaced: false,
                }));
                placedElements = [];
                
                // clear all cells
                document.querySelectorAll('.grid-cell').forEach(cell => {
                    cell.innerHTML = '';
                    cell.classList.remove('cell-occupied');
                    cell.dataset.occupied = 'false';
                    cell.dataset.elementId = '';
                });

                // render draggable cards (only unplaced)
                renderCards();
                updateWinMessage();
            }

            // ---------- RENDER ELEMENT CARDS (with color coding) ----------
            function renderCards() {
                cardsContainer.innerHTML = '';
                const unplaced = activeElements.filter(el => !el.isPlaced);
                
                unplaced.forEach(el => {
                    const card = document.createElement('div');
                    card.className = `element-card card-${el.group}`;
                    card.id = `drag-${el.id}`;
                    card.dataset.symbol = el.symbol;
                    card.dataset.elementId = el.id;
                    card.dataset.row = el.row;
                    card.dataset.col = el.col;
                    card.innerHTML = `${el.symbol} <span>${el.name}</span>`;
                    
                    // make draggable
                    card.draggable = false;
                    card.addEventListener('pointerdown', (e) => startDrag(e, card, el.id));
                    
                    cardsContainer.appendChild(card);
                });
            }

            // ---------- DRAG API (touch + mouse) ----------
            function startDrag(e, card, elemId) {
                e.preventDefault();
                e.stopPropagation();
                
                const el = activeElements.find(el => el.id === elemId);
                if (!el || el.isPlaced) return;

                draggingCard = card;
                dragElementId = elemId;
                card.setPointerCapture(e.pointerId);

                const rect = card.getBoundingClientRect();
                const containerRect = document.querySelector('.game-container').getBoundingClientRect();
                
                // store initial positions (relative to viewport)
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                
                // get current left/top percentage relative to container
                const computed = window.getComputedStyle(card);
                initialLeft = parseFloat(computed.left) || 0;
                initialTop = parseFloat(computed.top) || 0;

                // attach global listeners
                window.addEventListener('pointermove', onDrag);
                window.addEventListener('pointerup', onDragEnd);
                window.addEventListener('pointercancel', onDragEnd);
            }

            function onDrag(e) {
                e.preventDefault();
                if (!draggingCard) return;

                const deltaX = e.clientX - dragStartX;
                const deltaY = e.clientY - dragStartY;

                // move with transform for smoothness (no clipping)
                draggingCard.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                draggingCard.style.zIndex = '10000';
            }

            function onDragEnd(e) {
                e.preventDefault();
                if (!draggingCard || dragElementId === null) {
                    cleanup();
                    return;
                }

                const el = activeElements.find(el => el.id === dragElementId);
                if (!el) { cleanup(); return; }

                // get card center position
                const cardRect = draggingCard.getBoundingClientRect();
                const centerX = (cardRect.left + cardRect.right) / 2;
                const centerY = (cardRect.top + cardRect.bottom) / 2;

                // find grid cell under center
                const elementsAtPoint = document.elementsFromPoint(centerX, centerY);
                let targetCell = null;
                for (let elem of elementsAtPoint) {
                    if (elem.classList && elem.classList.contains('grid-cell')) {
                        targetCell = elem;
                        break;
                    }
                }

                let matched = false;
                if (targetCell) {
                    const targetRow = parseInt(targetCell.dataset.row);
                    const targetCol = parseInt(targetCell.dataset.col);
                    
                    if (targetRow === el.row && targetCol === el.col && targetCell.dataset.occupied === 'false') {
                        // CORRECT MATCH!
                        matched = true;
                        
                        // mark element as placed
                        el.isPlaced = true;
                        placedElements.push(el.id);
                        
                        // update cell
                        targetCell.dataset.occupied = 'true';
                        targetCell.dataset.elementId = el.id;
                        targetCell.classList.add('cell-occupied');
                        targetCell.innerHTML = `<div class="element-symbol">${el.symbol}</div>
                                                <div class="element-name">${el.name}</div>`;
                        
                        // scoring: alternate teams
                        if (currentTeam === 'left') {
                            leftTeamScore++;
                            currentTeam = 'right';
                        } else {
                            rightTeamScore++;
                            currentTeam = 'left';
                        }
                        updateScores();
                        
                        // remove card
                        draggingCard.remove();
                    }
                }

                if (!matched) {
                    // reset card position
                    draggingCard.style.transform = 'translate(0, 0)';
                }

                cleanup();
                renderCards(); // refresh cards list (removes placed ones)
                checkRoundComplete();

                function cleanup() {
                    window.removeEventListener('pointermove', onDrag);
                    window.removeEventListener('pointerup', onDragEnd);
                    window.removeEventListener('pointercancel', onDragEnd);
                    
                    if (draggingCard) {
                        draggingCard.style.transform = 'translate(0, 0)';
                        draggingCard.style.zIndex = '';
                    }
                    draggingCard = null;
                    dragElementId = null;
                }
            }

            function updateScores() {
                leftScoreEl.textContent = leftTeamScore;
                rightScoreEl.textContent = rightTeamScore;
            }

            function updateWinMessage() {
                const placedCount = activeElements.filter(el => el.isPlaced).length;
                const total = activeElements.length;
                winMsg.innerHTML = `‚öõÔ∏è ${placedCount}/${total} elements placed ‚Ä¢ Team turn: ${currentTeam === 'left' ? 'üîµ LEFT' : 'üî¥ RIGHT'}`;
            }

            function checkRoundComplete() {
                const placedCount = activeElements.filter(el => el.isPlaced).length;
                const total = activeElements.length;
                updateWinMessage();
                
                if (placedCount === total && total > 0) {
                    winMsg.innerHTML = 'üéâ ROUND COMPLETE! Click "ADD ELEMENTS" for more! üéâ';
                }
            }

            // ---------- RESET / NEXT ROUND ----------
            function resetGame() {
                leftTeamScore = 0;
                rightTeamScore = 0;
                currentTeam = 'left';
                currentRound = 0;
                updateScores();
                buildGrid();
                loadRound(currentRound);
            }

            function nextRound() {
                currentRound++;
                if (currentRound >= ROUND_LEVELS.length) currentRound = ROUND_LEVELS.length - 1;
                // preserve scores, but load more elements
                loadRound(currentRound);
                updateWinMessage();
            }

            // ---------- INITIALIZE ----------
            function init() {
                // first, detect screen size
                adjustGridToScreen();
                buildGrid();
                resetGame(); // sets scores and first round
            }

            // Event listeners
            resetBtn.addEventListener('click', resetGame);
            nextBtn.addEventListener('click', nextRound);

            // prevent touch scrolling on cards
            window.addEventListener('touchstart', (e) => {
                if (e.target.classList.contains('element-card')) e.preventDefault();
            }, { passive: false });

            // start everything
            init();
        })();
    </script>
</body>
</html>